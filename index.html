<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<meta http-equiv="X-UA-Compatible" content="chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
<link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
<!--[if lt IE 9]>
<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<title>ph-schematron by Philip Helger</title>
</head>
<body>
	<header>
		<div class="inner">
			<h1>ph-schematron</h1>
			<h2>Java Schematron library that supports XSLT and native application</h2>
			<a href="https://github.com/phax/ph-schematron" class="button"><small>View project on</small> GitHub</a>
    </div>
	</header>

	<div id="content-wrapper">
		<div class="inner clearfix">
			<section id="main-content">
				<h1>
					<a name="ph-schematron" class="anchor" href="#ph-schematron"><span
						class="octicon octicon-link"></span></a>ph-schematron
				</h1>

				<p>
					ph-schematron is a Java library that validates XML documents via <a
						href="http://www.schematron.com">ISO Schematron</a>. It offers
					several different possibilities to perform this task where each
					solution offers its own advantages and disadvantages that are
					outlined below in more detail. ph-schematron only supports ISO
					Schematron and no other Schematron version. The most common way is
					to convert the source Schematron file to an XSLT script and apply
					this XSLT on the XML document to be validated. Alternatively
					ph-schematron offers a native implementation for the Schematron
					XPath binding which offers superior performance over the XSLT
					approach but has some other minor limitations.
				</p>
	
				<h2>
					<a name="prerequisites" class="anchor" href="#prerequisites"><span
						class="octicon octicon-link"></span></a>Prerequisites
				</h2>

				<p>
					It is assumed that you have a basic knowledge what Schematron is,
					and what Schematron can do for you. A good introduction can be
					found in Dave Pawsons Schematron tutorial at <a
						href="http://www.dpawson.co.uk/schematron/">http://www.dpawson.co.uk/schematron/</a>.
					It is also assumed that you have basic knowledge of the Java
					language, so that you can understand the code examples, that you
					have at least basic understanding of XSLT (Extensible Stylesheet
					Language Transformations) and that you have good knowledge of XML
					itself.
				</p>

				<h1>
					<a name="xml-document-validation" class="anchor"
						href="#xml-document-validation"><span
						class="octicon octicon-link"></span></a>XML document validation
				</h1>

				<p>The goal of Schematron is to provide validation mechanisms
					for XML documents that are beyond DTD and XML Schema. DTD and XML
					Schema both purely test the structure and the data types of the
					content of an XML document whereas Schematron can check relations
					and structure of an XML document.</p>

				<p>The most basic type of validation is to check, if an XML
					document confirms to a set of Schematron rules or not. So the
					output of the basic check is either "true" - meaning the XML
					document conforms to the Schematron rules - or "false" - meaning
					that the XML document does not conform to the Schematron rules.
					Additionally Schematron defines a result document type called
					"SVRL" which is short for "Schematron Validation Report Language".
					It is a more complex, XML-based result that outlines exactly what
					assertions failed and what reports succeeded. ph-schematron is
					capable of performing both types of validation.</p>

				<h2>
					<a name="validation-via-xslt" class="anchor"
						href="#validation-via-xslt"><span class="octicon octicon-link"></span></a>Validation
					via XSLT
				</h2>

				<p>The proposed way to perform a Schematron validation is to
					apply a set of three pre-defined XSLT scripts onto a Schematron
					file. After these transformations the original Schematron rule set
					has been transformed into an XSLT script itself, which can then be
					applied onto XML documents for validation. The output of this
					validation is an SVRL document. Because the pre-compilation step
					from Schematron to XSLT is very time consuming (it can take many
					minutes for a mid-sized Schematron rule set), it is strongly
					suggested to cache the resulting XSLT script, as it can be applied
					to all XML documents to be validated. Please note that the created
					Schematron XSLT scripts differ when you choose a special Schematron
					phase!</p>

				<p>
					ph-schematron ships with a special Apache Maven plugin called <a
						href="https://github.com/phax/ph-schematron">ph-schematron2xslt-maven-plugin</a>
					that can be used to create the XSLT scripts from Schematron files
					during build time. It is described in more detail below.
				</p>

				<h2>
					<a name="validation-via-pure-schematron" class="anchor"
						href="#validation-via-pure-schematron"><span
						class="octicon octicon-link"></span></a>Validation via Pure Schematron
				</h2>

				<p>As an alternative to the XSLT-based approach, ph-schematron
					provides a pure Java implementation which will be referred to as
					"Pure Schematron" within this document. With Pure Schematron the
					same results can be achieved as with the XSLT approach: basic
					validity checks and SVRL output documents.</p>

				<p>The advantage of Pure Schematron is that you don't need to
					apply the timely conversion to XSLT before you can start
					validating. The internal steps for validating an XML document with
					Pure Schematron are the following:</p>

				<ol>
					<li>Read the Schematron resource from a file or a URL or
						create it manually. When reading an existing Schematron resource,
						all Schematron includes are resolved, so that one large Schematron
						document is created.</li>
					<li>Determine the query binding to be used. ph-schematron
						ships with a standard XPath binding that will be used if none is
						specified.</li>
					<li>Now the Schematron needs to be pre-processed, to resolve
						abstract patterns, abstract rules and perform variable
						replacement.</li>
					<li>Finally the pre-processed Schematron must be "bound". In
						this step a Schematron phase can be selected which should be used.
						When the default query binding is used, all XPath expressions are
						pre-compiled so that they can be evaluated faster. When you supply
						your own query binding, you need to make sure to create an
						efficient representation to use as a bound schema.</li>
					<li>This created bound schema can now be used to validate
						arbitrary XML documents. Ideally it should also be cached like the
						XSLT script from above, because the XPath compilation is kind of
						costly, but by far not as costly as the XSLT creation.</li>
				</ol>
				<p>Pure Schematron is designed for maximum extensibility,
					meaning that you can create your own query binding, configure the
					reading and pre-processing of Schematron objects etc. The drawbacks
					of Pure Schematron are currently:</p>

				<ul>
					<li>Include handling, as it works only when you read a
						Schematron from a resource and not if you create your Schematron
						from scratch. If you have this in mind when creating your
						Schematron files it should not affect you much.</li>
					<li>XML attributes and elements from other namespaces are read
						from an existing Schematron resource but they have no impact on
						the validation process itself when the default query binding is
						used. If you have an idea how this can be solved in a proper way,
						please drop me an email.</li>
				</ul>
				<p>
					Additionally ph-schematron gives you the possibility to write a
					Schematron rule set easily to disk, it offers the possibility to
					check whether a Schematron is minified, preprocessed and valid. It
					also supports validating a Schematron resource against the RelaxNG
					Compact scheme with the additional library called <a
						href="https://github.com/phax/ph-schematron-validator">ph-schematron-validator</a>.
					This library was externalized because it is not used in any regular
					workflow and brings a lot of additional dependencies.
				</p>

				<h1>
					<a name="technical-details" class="anchor"
						href="#technical-details"><span class="octicon octicon-link"></span></a>Technical
					details
				</h1>

				<p>
					ph-schematron is an operating system independent Java 1.8 library (up to 
					and including v3.0.1 the library was targeted for Java 1.6).
					As the underlying XPath Engine <a
						href="http://saxon.sourceforge.net/">SaxonHE 9.x HE</a> is used.
					Compared to <a href="http://xml.apache.org/xalan-j/">Apache
						Xalan 2.7.1</a> it offers more XPath functions out of the box.
					ph-schematron also depends on the OSS library <a
						href="https://github.com/phax/ph-commons">ph-commons</a>.
				</p>

				<p>
					As the determination of the XPath engine is triggered by JAXP also
					the debugging mechanisms of JAXP must be used, to determine which
					XPath engine is effectively used. The simplest way to do this is to
					set the system property
					<code>jaxp.debug</code>
					to
					<code>true</code>
					before starting to work with Schematron. In this case the console
					will contain log messages that show what
					<code>XPathFactory</code>
					was loaded.
				</p>

				<p>
					ph-schematron is built as an OSGI bundle via the
					org.apache.felix:maven-bundle-plugin. The full code of the examples
					used in this document can be found in the file <a
						href="https://github.com/phax/ph-schematron/blob/master/ph-schematron/src/test/java/com/helger/schematron/docs/DocumentationExamples.java">DocumentationExamples.java</a>.
				</p>

				<h2>
					<a name="usage-with-maven" class="anchor" href="#usage-with-maven"><span
						class="octicon octicon-link"></span></a>Usage with Maven
				</h2>

				<p>ph-schematron is build with Apache Maven. If you want to
					build it from source, at least Maven 3.0.4 is required. The
					dependency for ph-schematron looks like this:</p>

				<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.helger&lthttps://github.com/Schematron/schema/blob/master/svrl.rnc;/groupId&gt;
  &lt;artifactId&gt;ph-schematron&lt;/artifactId&gt;
  &lt;version&gt;5.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

				<p>It transitively contains ph-commons, SLF4J and Saxon HE.</p>

				<h2>
					<a name="common-api" class="anchor" href="#common-api"><span
						class="octicon octicon-link"></span></a>Common API
				</h2>

				<p>
					A common API for both XSLT and Pure Schematron approach is
					available via the
					<code>com.helger.schematron.ISchematronResource</code>
					interface. It is meant for Schematron that is read from a file or
					URL. It offers the possibility to check if the read Schematron is
					valid itself via the
					<code>boolean isValidSchematron ()</code>
					method.
				</p>

				<p>
					To check if an XML document simply matches a Schematron rule set
					the methods
					<code>com.helger.commons.state.EValidity
						getSchematronValidity(…)</code>
					are provided. These methods deliver either
					<code>EValidity.VALID</code>
					if the XML document matches the Schematron or
					<code>EValidity.INVALID</code>
					if the XML document does not match at least one Schematron rule.
					With this method you have no possibility to determine what the
					error exactly was. When using an XSLT based implementation this
					method does not offer any performance improvement, as the SVRL is
					fully created and analyzed afterwards. When using a Pure Schematron
					based implementation, the validation stops after the first error
					and does not continue to validate the supplied XML document.
				</p>

				<p>
					Alternatively to the basic validation the interface also offers the
					possibility to create an SVRL result via the methods
					<code>org.w3c.dom.Document applySchematronValidation(…)</code>
					and
					<code>org.oclc.purl.dsdl.svrl.SchematronOutputType applySchematronValidationToSVRL(…)</code>
					. The first method type creates the SVRL only as an XML document
					node, where the second method type applies a JAXB binding, so that
					it is easier to access the information inside the SVRL. Internally
					these methods call each other depending on the concrete
					implementation, so they are ensured to deliver exactly the same
					result. The XSLT implementation is natively done in
					<code>applySchematronValidation</code>
					and then converted to a
					<code>SchematronOutputType</code>
					using the
					<code>com.helger.schematron.svrl.SVRLMarshaller</code>
					class. With Pure Schematron a
					<code>SchematronOutputType</code>
					object is directly created and then converted to an XML document
					node via the class
					<code>com.helger.schematron.svrl.SVRLMarshaller</code>
					.
        </p>
        <p>  
          Prior to v5 there were classes called <code>SVRLReader</code>
          to read SVRL documents and <code>SVRLWriter</code> to write
          SVRL documents, but they only called <code>SVRLMarshaller</code>
          but didn't offer all the flexibility needed. So they were
          removed in v5. 
				</p>

				<p>
					The classes
					<code>SVRLReader</code>
					and
					<code>SVRLWriter</code>
					can generically be used to read and write SVRL files in a
					structured way. Both classes validate the SVRL based on SVRL XML
					Schema contained in the library.
				</p>

				<h3>
					<a name="validation-via-xslt-1" class="anchor"
						href="#validation-via-xslt-1"><span
						class="octicon octicon-link"></span></a>Validation via XSLT
				</h3>

				<p>As described above it is highly recommended to cache the XSLT
					script that is created from the source Schematron rule set.
					Nevertheless ph-schematron offers both possibilities to use
					Schematron.</p>

				<p>
					The easiest way to start working is by starting from a Schematron
					file.
					<code>com.helger.schematron.xslt.SchematronResourceSCH</code>
					is the implementation of the
					<code>ISchematronResource</code>
					interface to be used for this. The constructor takes at the least
					the Schematron resource that contains the rules. When using this
					class it is possibly to specify an optional Schematron phase to be
					used for validation. Additionally some static factory methods are
					present that allow creating
					<code>SchematronResourceSCH objects</code>
					from a
					<code>String</code>
					path or a
					<code>java.io.File</code>
					object.
				</p>

				<p>
					If a precompiled XSLT script is present (e.g. via the
					schematron2xslt Maven plugin or via manual pre-processing) the
					implementation class
					<code>com.helger.schematron.xslt.SchematronResourceXSLT</code>
					should be instantiated. It offers the same constructors and factory
					methods as the
					<code>SchematronResourceSCH</code>
					class. Please recall that the chosen phase already affected the
					created XSLT script, so it is not possible to specify a phase when
					using this implementation.
				</p>

				<p>
					Both implementations use an internal cache that keeps the created
					pre-precompiled
					<code>javax.xml.transform.Templates</code>
					objects in memory while the application is running. The cache for
					<code>SchematronResourceSCH</code>
					is located in the class
					<code>com.helger.schematron.xslt.SchematronResourceSCHCache</code>
					whereas the cache for
					<code>SchematronResourceXSLT</code>
					is located in the class
					<code>com.helger.schematron.xslt.SchematronResourceXSLTCache</code>
					– big surprise :)
				</p>

				<p>
					A simple example to validate an XML file (to
					<code>true</code>
					or
					<code>false</code>
					) based on Schematron rules from a file looks like this:
				</p>

				<div class="highlight highlight-java">
					<pre><span class="kd">public</span> <span class="kd">static</span> <span
							class="kt">boolean</span> <span class="nf">validateXMLViaXSLTSchematron</span> <span
							class="o">(</span><span class="nd">@Nonnull</span> <span
							class="kd">final</span> <span class="n">File</span> <span
							class="n">aSchematronFile</span><span class="o">,</span> <span
							class="nd">@Nonnull</span> <span class="kd">final</span> <span
							class="n">File</span> <span class="n">aXMLFile</span><span
							class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span>
<span class="o">{</span>
  <span class="kd">final</span> <span class="n">ISchematronResource</span> <span
							class="n">aResSCH</span> <span class="o">=</span> <span class="n">SchematronResourceSCH</span><span
							class="o">.</span><span class="na">fromFile</span> <span
							class="o">(</span><span class="n">aSchematronFile</span><span
							class="o">);</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">aResSCH</span><span
							class="o">.</span><span class="na">isValidSchematron</span> <span
							class="o">())</span>
    <span class="k">throw</span> <span class="k">new</span> <span
							class="nf">IllegalArgumentException</span> <span class="o">(</span><span
							class="s">"Invalid Schematron!"</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">aResSCH</span><span
							class="o">.</span><span class="na">getSchematronValidity</span> <span
							class="o">(</span><span class="k">new</span> <span class="nf">StreamSource</span><span
							class="o">(</span><span class="n">aXMLFile</span><span class="o">)).</span><span
							class="na">isValid</span> <span class="o">();</span>
<span class="o">}</span>
</pre>
				</div>

				<p>The same example but creating a real SVRL output looks like
					this:</p>

				<div class="highlight highlight-java">
					<pre><span class="kd">public</span> <span class="kd">static</span> <span
							class="n">SchematronOutputType</span> <span class="nf">validateXMLViaXSLTSchematronFull</span> <span
							class="o">(</span><span class="nd">@Nonnull</span> <span
							class="kd">final</span> <span class="n">File</span> <span
							class="n">aSchematronFile</span><span class="o">,</span> <span
							class="nd">@Nonnull</span> <span class="kd">final</span> <span
							class="n">File</span> <span class="n">aXMLFile</span><span
							class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span>
<span class="o">{</span>
  <span class="kd">final</span> <span class="n">ISchematronResource</span> <span
							class="n">aResSCH</span> <span class="o">=</span> <span class="n">SchematronResourceSCH</span><span
							class="o">.</span><span class="na">fromFile</span> <span
							class="o">(</span><span class="n">aSchematronFile</span><span
							class="o">);</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">aResSCH</span><span
							class="o">.</span><span class="na">isValidSchematron</span> <span
							class="o">())</span>
    <span class="k">throw</span> <span class="k">new</span> <span
							class="nf">IllegalArgumentException</span> <span class="o">(</span><span
							class="s">"Invalid Schematron!"</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">aResSCH</span><span
							class="o">.</span><span class="na">applySchematronValidationToSVRL</span> <span
							class="o">(</span><span class="k">new</span> <span class="nf">StreamSource</span> <span
							class="o">(</span><span class="n">aXMLFile</span><span class="o">));</span>
<span class="o">}</span>
</pre>
				</div>

				<p>
					The difference to the simple example is that instead of the method
					<code>getSchematronValidity</code>
					the method
					<code>applySchematronValidationToSVRL</code>
					is invoked.
				</p>

				<h3>
					<a name="validation-via-pure-schematron-1" class="anchor"
						href="#validation-via-pure-schematron-1"><span
						class="octicon octicon-link"></span></a>Validation via Pure Schematron
				</h3>

				<p>
					For Pure Schematron the implementation of the
					<code>ISchematronResource</code>
					interface resides in the class
					<code>com.helger.schematron.pure.SchematronResourcePure</code>
					. The constructor also takes at least the resource where to read
					the Schematron rules from. Additional a Schematron phase and a
					custom error handler can be supplied.
				</p>

				<p>
					Be careful when using the validation methods that take a
					<code>javax.xml.transform.Source</code>
					object as parameter. Only
					<code>DOMSource</code>
					and
					<code>StreamSource</code>
					objects are supported at the moment!
				</p>

				<p>A simple example to validate an XML file based on Schematron
					rules from a file looks like this:</p>

				<div class="highlight highlight-java">
					<pre><span class="kd">public</span> <span class="kd">static</span> <span
							class="kt">boolean</span> <span class="nf">validateXMLViaPureSchematron</span> <span
							class="o">(</span><span class="nd">@Nonnull</span> <span
							class="kd">final</span> <span class="n">File</span> <span
							class="n">aSchematronFile</span><span class="o">,</span> <span
							class="nd">@Nonnull</span> <span class="kd">final</span> <span
							class="n">File</span> <span class="n">aXMLFile</span><span
							class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span>
<span class="o">{</span>
  <span class="kd">final</span> <span class="n">ISchematronResource</span> <span
							class="n">aResPure</span> <span class="o">=</span> <span
							class="n">SchematronResourcePure</span><span class="o">.</span><span
							class="na">fromFile</span> <span class="o">(</span><span
							class="n">aSchematronFile</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">aResPure</span><span
							class="o">.</span><span class="na">isValidSchematron</span> <span
							class="o">())</span>
    <span class="k">throw</span> <span class="k">new</span> <span
							class="nf">IllegalArgumentException</span> <span class="o">(</span><span
							class="s">"Invalid Schematron!"</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">aResPure</span><span
							class="o">.</span><span class="na">getSchematronValidity</span><span
							class="o">(</span><span class="k">new</span> <span class="nf">StreamSource</span><span
							class="o">(</span><span class="n">aXMLFile</span><span class="o">)).</span><span
							class="na">isValid</span> <span class="o">();</span>
<span class="o">}</span>
</pre>
				</div>

				<p>As an alternative you can also validate via the internal API
					as well, in which case the code can look like this:</p>

				<div class="highlight highlight-java">
					<pre><span class="kd">public</span> <span class="kd">static</span> <span
							class="kt">boolean</span> <span class="nf">validateXMLViaPureSchematron2</span> <span
							class="o">(</span><span class="nd">@Nonnull</span> <span
							class="kd">final</span> <span class="n">File</span> <span
							class="n">aSchematronFile</span><span class="o">,</span> <span
							class="nd">@Nonnull</span> <span class="kd">final</span> <span
							class="n">File</span> <span class="n">aXMLFile</span><span
							class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span>
<span class="o">{</span>
  <span class="c1">// Read the schematron from file</span>
  <span class="kd">final</span> <span class="n">PSSchema</span> <span
							class="n">aSchema</span> <span class="o">=</span> <span class="k">new</span> <span
							class="nf">PSReader</span> <span class="o">(</span><span
							class="k">new</span> <span class="nf">FileSystemResource</span> <span
							class="o">(</span><span class="n">aSchematronFile</span><span
							class="o">)).</span><span class="na">readSchema</span> <span
							class="o">();</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">aSchema</span><span
							class="o">.</span><span class="na">isValid</span> <span class="o">())</span>
    <span class="k">throw</span> <span class="k">new</span> <span
							class="nf">IllegalArgumentException</span> <span class="o">(</span><span
							class="s">"Invalid Schematron!"</span><span class="o">);</span>
  <span class="c1">// Resolve the query binding to use</span>
  <span class="kd">final</span> <span class="n">IPSQueryBinding</span> <span
							class="n">aQueryBinding</span> <span class="o">=</span> <span
							class="n">PSQueryBindingRegistry</span><span class="o">.</span><span
							class="na">getQueryBindingOfNameOrThrow</span> <span class="o">(</span><span
							class="n">aSchema</span><span class="o">.</span><span class="na">getQueryBinding</span> <span
							class="o">());</span>
  <span class="c1">// Pre-process schema</span>
  <span class="kd">final</span> <span class="n">PSPreprocessor</span> <span
							class="n">aPreprocessor</span> <span class="o">=</span> <span
							class="k">new</span> <span class="nf">PSPreprocessor</span> <span
							class="o">(</span><span class="n">aQueryBinding</span><span
							class="o">);</span>
  <span class="n">aPreprocessor</span><span class="o">.</span><span
							class="na">setKeepTitles</span> <span class="o">(</span><span
							class="kc">true</span><span class="o">);</span>
  <span class="kd">final</span> <span class="n">PSSchema</span> <span
							class="n">aPreprocessedSchema</span> <span class="o">=</span> <span
							class="n">aPreprocessor</span><span class="o">.</span><span
							class="na">getAsPreprocessedSchema</span> <span class="o">(</span><span
							class="n">aSchema</span><span class="o">);</span>
  <span class="c1">// Bind the pre-processed schema</span>
  <span class="kd">final</span> <span class="n">IPSBoundSchema</span> <span
							class="n">aBoundSchema</span> <span class="o">=</span> <span
							class="n">aQueryBinding</span><span class="o">.</span><span
							class="na">bind</span> <span class="o">(</span><span class="n">aPreprocessedSchema</span><span
							class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span
							class="kc">null</span><span class="o">);</span>
  <span class="c1">// Read the XML file</span>
  <span class="kd">final</span> <span class="n">Document</span> <span
							class="n">aXMLNode</span> <span class="o">=</span> <span
							class="n">DOMReader</span><span class="o">.</span><span
							class="na">readXMLDOM</span> <span class="o">(</span><span
							class="n">aXMLFile</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">aXMLNode</span> <span
							class="o">==</span> <span class="kc">null</span><span class="o">)</span>
    <span class="k">return</span> <span class="kc">false</span><span
							class="o">;</span>
  <span class="c1">// Perform the validation</span>
  <span class="k">return</span> <span class="n">aBoundSchema</span><span
							class="o">.</span><span class="na">validatePartially</span> <span
							class="o">(</span><span class="n">aXMLNode</span><span class="o">).</span><span
							class="na">isValid</span> <span class="o">();</span>
<span class="o">}</span>
</pre>
				</div>

				<p>The code is clearly separated into the following steps:</p>

				<ul>
					<li>Reading the Schematron file from a File (lines 04-06).
						This part contains the Schematron include resolution.</li>
					<li>Determine the Schematron query binding to be used (line
						08). The query binding is required to correctly pre-process the
						Schematron afterwards.</li>
					<li>Pre-process the read Schematron file (line 10-12). This
						resolves all abstract rules and patterns.</li>
					<li>Create the bound Schematron (line 14). This is the
						pre-compilation step, depending on the selected query binding. The
						second parameter that is <code>null</code> in the example is the
						name of the phase to use. When no phase is passed the <code>defaultPhase</code>
						attribute of the Schematron schema is checked and used. If no <code>defaultPhase</code>
						is present, all patterns are active.
					</li>
					<li>Read the XML file to be validated via DOM (line 16-18).
						Technical note: this is the class <code>com.helger.commons.xml.serialize.DOMReader</code>
						which offers a simplified API to read XML files and is not be
						confused with a class with the same name in DOM4J.
					</li>
					<li>Perform the Schematron validation of the read XML file
						(line 20).</li>
				</ul>
				<p>It is important to note, that in the second case no caching
					is performed, and that the Schematron file is interpreted each time
					the method is called, which may not be as efficient as possible.</p>

				<p>
					The most customization may be done to the pre-processor. The
					Schematron ISO standard defines a "Minimal Syntax" that is still
					compliant Schematron but among other with all includes resolved,
					all abstract patterns and abstract rules resolved. Because a
					Schematron that is minified has implications on the created SVRL
					document it was chosen to call the class <em>PSPreprocessor</em>
					and not <em>PSMinifier</em>. For example if all
					<code>&lt;report&gt;</code>
					elements are converted to
					<code>&lt;assert&gt;</code>
					elements, the SVRL would contain a
					<code>&lt;failed-assert&gt;</code>
					element instead of a
					<code>&lt;successful-report&gt;</code>
					element. By default the pre-processor creates a minimal Schematron
					but if offers the possibility to avoid certain minimizations.
				</p>

				<h2>
					<a name="extensibility-of-pure-schematron" class="anchor"
						href="#extensibility-of-pure-schematron"><span
						class="octicon octicon-link"></span></a>Extensibility of Pure
					Schematron
				</h2>

				<h3>
					<a name="reading" class="anchor" href="#reading"><span
						class="octicon octicon-link"></span></a>Reading
				</h3>

				<p>
					Pure Schematron can be extended in several ways. The reading itself
					is not very customizable, but after reading you have the
					possibility to modify the created Schematron object of type
					<code>com.helger.schematron.pure.model.PSSchema</code>
					. It offers getter and setter for all elements. The object
					hierarchy of
					<code>PSSchema</code>
					is very similar to the XML hierarchy of Schematron in general so it
					should not be too hard to handle. E.g. a
					<code>PSSchema</code>
					has a list of
					<code>PSPattern</code>
					objects, which in turn each have a list of
					<code>PSRule</code>
					elements. Via the method
					<code>IMicroElement getAsMicroElement ()</code>
					each Schematron object can easily be converted to an XML structure
					which can than easily be serialized to disk. The following example
					reads a Schematron file from disc, sets a
					<code>&lt;title&gt;</code>
					element and writes the document back to the source file:
				</p>

				<div class="highlight highlight-java">
					<pre><span class="kd">public</span> <span class="kd">static</span> <span
							class="kt">boolean</span> <span class="nf">readModifyAndWrite</span> <span
							class="o">(</span><span class="nd">@Nonnull</span> <span
							class="kd">final</span> <span class="n">File</span> <span
							class="n">aSchematronFile</span><span class="o">)</span> <span
							class="kd">throws</span> <span class="n">Exception</span>
<span class="o">{</span>
  <span class="kd">final</span> <span class="n">PSSchema</span> <span
							class="n">aSchema</span> <span class="o">=</span> <span class="k">new</span> <span
							class="nf">PSReader</span> <span class="o">(</span><span
							class="k">new</span> <span class="nf">FileSystemResource</span> <span
							class="o">(</span><span class="n">aSchematronFile</span><span
							class="o">)).</span><span class="na">readSchema</span> <span
							class="o">();</span>
  <span class="kd">final</span> <span class="n">PSTitle</span> <span
							class="n">aTitle</span> <span class="o">=</span> <span class="k">new</span> <span
							class="nf">PSTitle</span> <span class="o">();</span>
  <span class="n">aTitle</span><span class="o">.</span><span class="na">addText</span> <span
							class="o">(</span><span class="s">"Created by ph-schematron"</span><span
							class="o">);</span>
  <span class="n">aSchema</span><span class="o">.</span><span class="na">setTitle</span> <span
							class="o">(</span><span class="n">aTitle</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">MicroWriter</span><span
							class="o">.</span><span class="na">writeToFile</span> <span
							class="o">(</span><span class="n">aSchema</span><span class="o">.</span><span
							class="na">getAsMicroElement</span> <span class="o">(),</span> <span
							class="n">aSchematronFile</span><span class="o">).</span><span
							class="na">isSuccess</span> <span class="o">();</span>
<span class="o">}</span>
</pre>
				</div>

				<h3>
					<a name="new-query-binding" class="anchor"
						href="#new-query-binding"><span class="octicon octicon-link"></span></a>New
					Query Binding
				</h3>

				<p>
					It is also possible to implement your own query binding that is
					different from the default XPath-based query binding. Therefore a
					class implementing the interface
					<code>com.helger.schematron.pure.binding.IPSQueryBinding</code>
					must be present. This implementation class must then be registered
					in the
					<code>com.helger.schematron.pure.binding.PSQueryBindingRegistry</code>
					via the static method
					<code>registerQueryBinding</code>
					. It is not possible to replace an existing query binding. The
					predefined XPath-based query binding is registered to the names <em>xslt</em>
					and <em>xslt2</em> as well as to the default (meaning unspecified)
					query binding. Implementing your own query binding is kind of time
					consuming as you need to implement at least the interfaces
					<code>com.helger.schematron.pure.binding.IPSQueryBinding</code>
					and
					<code>com.helger.schematron.pure.bound.IPSBoundSchema</code>
					.
				</p>

				<h3>
					<a name="modify-existing-query-binding" class="anchor"
						href="#modify-existing-query-binding"><span
						class="octicon octicon-link"></span></a>Modify Existing Query Binding
				</h3>

				<p>
					Additionally you may alter the existing Schematron processing by
					either using the Pure Schematron API as outlined in the example
					above or you may subclass
					<code>com.helger.schematron.pure.bound.PSBoundSchemaCacheKey</code>
					which offers a set of protected methods for easy customization when
					using
					<code>SchematronResourcePure</code>
					. In case you have a customized implementation, you need to use the
					special
					<code>SchematronResourcePure</code>
					constructor taking the Schematron
					<code>IReadableResource</code>
					and the
					<code>PSBoundSchemaCacheKey</code>
					implementation. See the documentation in the code for details on
					overriding
					<code>PSBoundSchemaCacheKey</code>
					.
				</p>

				<h1>
					<a name="benchmarks" class="anchor" href="#benchmarks"><span
						class="octicon octicon-link"></span></a>Benchmarks
				</h1>

				<p>As I had no time to do a real benchmark here are at least my
					unofficial findings. The pure validation is about 40-50% faster
					when the same Schematron is applied on the same XML over and over
					again. As both the XSLT and the Pure Schematron solutions
					internally use a cache, I assume that this will hold true when
					validating different XML files with the same rule set.</p>

				<h1>
					<a name="known-issues" class="anchor" href="#known-issues"><span
						class="octicon octicon-link"></span></a>Known issues
				</h1>

				<h2>
					<a name="element-order-inconsistency" class="anchor"
						href="#element-order-inconsistency"><span
						class="octicon octicon-link"></span></a>Element order inconsistency
				</h2>

				<p>I recently discovered an inconsistency between the Pure and
					the XSLT based version. The Schematron is the following:</p>

				<div class="highlight highlight-xml">
					<pre><span class="nt">&lt;sch:schema</span> <span class="na">xmlns:sch=</span><span
							class="s">"http://purl.oclc.org/dsdl/schematron"</span> <span
							class="na">xml:lang=</span><span class="s">"de"</span><span
							class="nt">&gt;</span>
  <span class="nt">&lt;sch:title&gt;</span>Example of Multi-Lingual Schema<span
							class="nt">&lt;/sch:title&gt;</span>
  <span class="nt">&lt;sch:pattern&gt;</span>
    <span class="nt">&lt;sch:rule</span> <span class="na">context=</span><span
							class="s">"dog"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;sch:assert</span> <span class="na">test=</span><span
							class="s">"bone"</span> <span class="na">diagnostics=</span><span
							class="s">"d1 d2"</span><span class="nt">&gt;</span> A dog should have a bone.<span
							class="nt">&lt;/sch:assert&gt;</span>
    <span class="nt">&lt;/sch:rule&gt;</span>
  <span class="nt">&lt;/sch:pattern&gt;</span>
  <span class="nt">&lt;sch:diagnostics&gt;</span>
    <span class="nt">&lt;sch:diagnostic</span> <span class="na">id=</span><span
							class="s">"d1"</span> <span class="na">xml:lang=</span><span
							class="s">"en"</span><span class="nt">&gt;</span> A dog should have a bone.<span
							class="nt">&lt;/sch:diagnostic&gt;</span>
    <span class="nt">&lt;sch:diagnostic</span> <span class="na">id=</span><span
							class="s">"d2"</span> <span class="na">xml:lang=</span><span
							class="s">"de"</span><span class="nt">&gt;</span> Das  Hund muss ein Bein haben.<span
							class="nt">&lt;/sch:diagnostic&gt;</span>
  <span class="nt">&lt;/sch:diagnostics&gt;</span>
<span class="nt">&lt;/sch:schema&gt;</span>
</pre>
				</div>

				<p>The respective XML file to validate is</p>

				<div class="highlight highlight-xml">
					<pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="nt">&lt;dog</span> <span class="na">xml:lang=</span><span
							class="s">"de"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;fleas/&gt;</span>
<span class="nt">&lt;/dog&gt;</span>
</pre>
				</div>

				<p>When using Pure Schematron, the output is</p>

				<div class="highlight highlight-xml">
					<pre><span class="cp">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</span>
<span class="nt">&lt;schematron-output</span> <span class="na">title=</span><span
							class="s">"Example of Multi-Lingual Schema"</span> <span
							class="na">xmlns=</span><span class="s">"http://purl.oclc.org/dsdl/svrl"</span><span
							class="nt">&gt;</span>
  <span class="nt">&lt;active-pattern/&gt;</span>
  <span class="nt">&lt;fired-rule</span> <span class="na">context=</span><span
							class="s">"//dog"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;failed-assert</span> <span class="na">test=</span><span
							class="s">"bone"</span> <span class="na">location=</span><span
							class="s">"//dog[0]"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;diagnostic-reference</span> <span class="na">diagnostic=</span><span
							class="s">"d1"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;text&gt;</span> A dog should have a bone. <span
							class="nt">&lt;/text&gt;</span>
    <span class="nt">&lt;/diagnostic-reference&gt;</span>
    <span class="nt">&lt;diagnostic-reference</span> <span class="na">diagnostic=</span><span
							class="s">"d2"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;text&gt;</span> Das Hund muss ein Bein haben. <span
							class="nt">&lt;/text&gt;</span>
    <span class="nt">&lt;/diagnostic-reference&gt;</span>
    <span class="nt">&lt;text&gt;</span> A dog should have a bone. <span
							class="nt">&lt;/text&gt;</span>
  <span class="nt">&lt;/failed-assert&gt;</span>
<span class="nt">&lt;/schematron-output&gt;</span>
</pre>
				</div>

				<p>Whereas when using the XSLT based version, the (formatted)
					output is</p>

				<div class="highlight highlight-xml">
					<pre>
<span class="cp">&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;</span>
<span class="nt">&lt;svrl:schematron-output</span> <span class="na">schemaVersion=</span><span class="s">""</span> 
  <span class="na">title=</span><span class="s">"Example of Multi-Lingual Schema"</span>
  <span class="na">xmlns:iso=</span><span class="s">"http://purl.oclc.org/dsdl/schematron"</span>
  <span class="na">xmlns:schold=</span><span class="s">"http://www.ascc.net/xml/schematron"</span> 
  <span class="na">xmlns:svrl=</span><span class="s">"http://purl.oclc.org/dsdl/svrl"</span> 
  <span class="na">xmlns:xhtml=</span><span class="s">"http://www.w3.org/1999/xhtml"</span>
  <span class="na">xmlns:xs=</span><span class="s">"http://www.w3.org/2001/XMLSchema"</span>
  <span class="nt">&gt;</span>
  <span class="nt">&lt;svrl:active-pattern</span> <span class="na">document=</span><span
							class="s">"...\ph-schematron\src\test\resources\issues\6\issue6.xml"</span> <span
							class="nt">/&gt;</span>
  <span class="nt">&lt;svrl:fired-rule</span> <span class="na">context=</span><span
							class="s">"dog"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;svrl:failed-assert</span> <span class="na">location=</span><span
							class="s">"/dog"</span> <span class="na">test=</span><span
							class="s">"bone"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;svrl:text&gt;</span> A dog should have a bone. <span
							class="nt">&lt;/svrl:text&gt;</span>
    <span class="nt">&lt;svrl:diagnostic-reference</span> <span
							class="na">diagnostic=</span><span class="s">"d1"</span> <span
							class="na">xml:lang=</span><span class="s">"en"</span><span
							class="nt">&gt;</span>
      A dog should have a bone.
    <span class="nt">&lt;/svrl:diagnostic-reference&gt;</span>
    <span class="nt">&lt;svrl:diagnostic-reference</span> <span
							class="na">diagnostic=</span><span class="s">"d2"</span> <span
							class="na">xml:lang=</span><span class="s">"de"</span><span
							class="nt">&gt;</span>
      Das Hund muss ein Bein haben.
    <span class="nt">&lt;/svrl:diagnostic-reference&gt;</span>
  <span class="nt">&lt;/svrl:failed-assert&gt;</span>
<span class="nt">&lt;/svrl:schematron-output&gt;</span>
</pre>
				</div>

				<p>
					and it’s easy to see that the order of
					<code>text</code>
					and
					<code>diagnostic-reference</code>
					within the
					<code>failed-assert</code>
					is different. According to the SVRL RNC 
          (<a href="https://github.com/Schematron/schema/blob/master/svrl.rnc">https://github.com/Schematron/schema/blob/master/svrl.rnc</a>)
					the order created by the Pure version is imho correct:
				</p>

				<pre><code># only failed assertions are reported
failed-assert = element failed-assert {
  attlist.assert-and-report, 
  diagnostic-reference*,
  property-reference*,
  human-text
}
</code>
				</pre>
				<p>So when using the XSLT based version together with diagnostic
					references the created SVRL does not necessarily comply to the
					SVRL-XSD file contained in ph-schematron.</p>
			</section>

			<aside id="sidebar">
				<a href="https://github.com/phax/ph-schematron/zipball/master" class="button"> <small>Download</small> .zip file</a> 
				<a href="https://github.com/phax/ph-schematron/tarball/master" class="button"> <small>Download</small> .tar.gz file</a>

				<p class="repo-owner">
					<a href="https://github.com/phax/ph-schematron"></a> is maintained by <a href="https://github.com/phax">Philip Helger</a>.
				</p>

        <form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
          <input type="hidden" name="cmd" value="_s-xclick"> 
          <input type="hidden" name="encrypted" value="-----BEGIN PKCS7-----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-----END PKCS7-----">
          <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
          <img alt="" border="0" src="https://www.paypalobjects.com/de_DE/i/scr/pixel.gif" width="1" height="1">
        </form>

        <a href="site-5.0.1/sitemap.html" class="button">Maven site 5.0.1</a>
        <a href="site-5.0.1/apidocs" class="button">API Docs 5.0.1</a>
        <p>
          Legacy docs:
        </p>
        <a href="site-4.3.4/sitemap.html" class="button">Maven site 4.3.4</a>
        <a href="site-4.3.4/apidocs" class="button">API Docs 4.3.4</a>
        <a href="site-4.0.0/sitemap.html" class="button">Maven site 4.0.0</a>
        <a href="site-4.0.0/apidocs" class="button">API Docs 4.0.0</a>
        <a href="site-3.0.1/sitemap.html" class="button">Maven site 3.0.1</a>
        <a href="site-3.0.1/apidocs" class="button">API Docs 3.0.1</a>
        <a href="site-2.9.1" class="button">Maven site 2.9.1</a>
        <a href="site-2.9.1/apidocs" class="button">API Docs 2.9.1</a>

				<p>
					This page was generated by 
					<a href="https://pages.github.com">GitHub Pages</a>
					using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
				</p>
			</aside>
		</div>
	</div>
</body>
</html>
